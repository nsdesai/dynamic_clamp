// Synaptic background conductances according to the point conductance model (Destexhe et al., Neurosci., 2001).
// Excitatory and inhibitory conductance trains are generated by Ornstein-Uhlenbeck processes.

const int gaussianPoolSize = 100;                 
float gaussianNumbers[gaussianPoolSize] = {0.0};   

// When the program is uploaded to the microcontroller, this function is called in order to create
// a pool of Gaussian random numbers for subsequent use by the OU processes 
void GenerateGaussianNumbers() {
  float x1,x2,w;
  int nIter = round(gaussianPoolSize/2);
  for (int x=0; x<nIter; x++) {
    w = 20.0;
    // Marsaglia polar method (a.k.a. Box-Mueller-Marsaglia) to obtain Gaussian random numbers
    while (w >= 1.0) {
      x1 = 2.0 * random(1001)/1000.0 - 1.0;
      x2 = 2.0 * random(1001)/1000.0 - 1.0;
      w = x1*x1 + x2*x2;
    }
    w = sqrtf((-2.0*log(w))/w);
    gaussianNumbers[2*x] = x1*w;
    gaussianNumbers[2*x+1] = x2*w;
  }
}

// This function calculates the current from the OU processes at every time step
// To integrate the OU processes, we use the approximation dt << tauExc,tauInh
float OrnsteinUhlenbeck(float v) {
  const float tauExc = 2.5;   // msec, time constant of excitatory process
  const float tauInh = 8.0;   // msec, time constant of inhibitory process   
  static float gOU1 = 0.0;         // nS, excitatory OU conductance
  static float gOU2 = 0.0;         // nS, inhibitory OU conductance
  float y1 = gaussianNumbers[random(gaussianPoolSize)];
  float y2 = gaussianNumbers[random(gaussianPoolSize)]; 
  // gOU1 is excitatory and gOU2 is inhibitory
  gOU1 = gOU1 + dt*(-(gOU1-OU1_mean)/tauExc) + sqrt(OU1_D*dt)*y1;
  gOU2 = gOU2 + dt*(-(gOU2-OU2_mean)/tauInh) + sqrt(OU2_D*dt)*y2;
  if (gOU1<0.0) gOU1=0.0;
  if (gOU2<0.0) gOU2=0.0;
  float current = -gOU1*v - gOU2*(v+80);    // Reversal potentials (0 mV excitatory, -80 mV inhibitory)
  return current;
}

